{"pages":[{"title":"关于独倾江月","text":"独倾江月 是 Gordon 的个人站。","link":"/about/index.html"}],"posts":[{"title":"使用自签名证书给安卓APP提供HTTPS后端服务","text":"在安卓开发中，我们希望可以用更安全的方式连接后端服务，且近几年较新的安卓Framework也一直在引导开发者使用Https安全链接。本文介绍了一种使用自签名证书的安卓Https链接方式。 需求背景关于Http与Https的区别，大家应该很熟悉，就不再赘述了。苹果iOS在好几年前就已强推Https，而安卓这边紧随其后，默认开发配置下也要求App只能使用Https，虽说目前最新版（10.0）仍然可以在manifest里设置一下规避掉，也只是过渡期的权宜之计罢了。 Https其实大家都想上，但证书问题却是个老大难。一方面，后端服务器可能没有域名，只有个IP，无法自由申请免费证书（可以给IP申请证书，但有很多限制，且可能收费）。另一方面，自签名证书很方便，但却没经过授权机构根证书签名，默认情况下得不到安卓系统的信任。因而，市面上仍有大量App使用不安全的Http协议连接Web后端服务。 解决方法通过多方搜索查找，综合官方文档，及相关博客，可以使用以下两步，验证自签名CA证书。另外，需注意生成证书时，应加入Subject Alternative Name参数，域名或者IP都行，具体参考这个SO回答。 PS：下面代码中的server.cer证书放入项目assets文件夹，获取方式可以参考相关博客，但不需要转为pem格式。 自定义证书验证器TrustManager1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package your.project.io;import java.io.BufferedInputStream;import java.security.KeyStore;import java.security.cert.Certificate;import java.security.cert.CertificateFactory;import java.util.Arrays;import javax.net.ssl.SSLContext;import javax.net.ssl.SSLSocketFactory;import javax.net.ssl.TrustManager;import javax.net.ssl.TrustManagerFactory;import javax.net.ssl.X509TrustManager;import your.project.Application;class MyTrustManager { private static SSLSocketFactory mSSLSocketFactory; private static X509TrustManager mTrustManager; static { try { KeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType()); keyStore.load(null, null); try (BufferedInputStream bis = new BufferedInputStream( Application.getApplicationContext().getAssets().open(\"ca/server.cer\"))) { Certificate ca = CertificateFactory.getInstance(\"X.509\").generateCertificate(bis); keyStore.setCertificateEntry(\"ca\", ca); } TrustManagerFactory trustManagerFactory = TrustManagerFactory .getInstance(TrustManagerFactory.getDefaultAlgorithm()); trustManagerFactory.init(keyStore); TrustManager[] trustManagers = trustManagerFactory.getTrustManagers(); if (trustManagers.length != 1 || !(trustManagers[0] instanceof X509TrustManager)) { throw new IllegalStateException(\"Unexpected default trust managers:\" + Arrays.toString(trustManagers)); } mTrustManager = (X509TrustManager) trustManagers[0]; SSLContext sslContext = SSLContext.getInstance(\"TLS\"); sslContext.init(null, trustManagers, null); mSSLSocketFactory = sslContext.getSocketFactory(); } catch (Exception e) { e.printStackTrace(); } } static SSLSocketFactory getSocketFactory() { return mSSLSocketFactory; } static X509TrustManager getTrustManager() { return mTrustManager; }} 在连接代理中使用定制的TrustManager在Http连接代理中设定TrustManager，这里以okhttp3第三方库的HttpClient为例： 1234567static final OkHttpClient client = new OkHttpClient.Builder() .sslSocketFactory(MyTrustManager.getSocketFactory(), MyTrustManager.getTrustManager()) // not safe, should specify subject alt name in server's ca. //.hostnameVerifier((hostname, session) -> Constants.Net.HOST.equals(hostname)) .connectTimeout(10, TimeUnit.SECONDS) .writeTimeout(20, TimeUnit.SECONDS) .readTimeout(20, TimeUnit.SECONDS).build(); 不出意外的话，App端应该可以正常用Https访问你的Web服务了。","link":"/2019/10/09/apply-https-to-android-app-with-self-signed-ca/"},{"title":"为家庭网络设置DDNS","text":"在家中网络架好以后，下一步就是要方便的随时访问家中的设备了。而即使申请到公网IP，一般家用级IP却不固定，给我们访问造成了麻烦。本博客介绍了解决这个问题的若干途径。 非DDNS方法（消息通知）这种方法是我最早在2017年时采用的，因当时国内比较知名的DDNS服务商，如花生壳啥的，已陆续不提供免费DDNS服务，故只能另辟蹊径，通过消息通知的方式来获取家网IP。 想过用微信推送，实现起来也简单，有一堆公众号支持HTTP GET/POST接口往特定微信号推送消息，但这种方式安全性不高，有暴露IP的风险，也不想为这件本应自己解决的事去专门关注公众号。另外有个考量点，我希望在电脑（Mac系统）上自动更新我的家网IP，这样的话，最好能利用到苹果系统本身的自带的App，可更好的与系统联动。 综合以上想法，并查阅资料后，我找到了一种还算顺畅的IP更新流程:路由器检测到IP变化 -> 将新IP用Email发出 -> 邮件服务器 -> 电脑接收邮件 -> 自动运行脚本更新hosts 检测IP变化cron定时任务如何检测本机外网IP发生变化？如果是在内网某台电脑上做检测，可能需要curl某个IP检测服务地址，如： 1curl myip.ipip.net 这样返回的信息中会包含外网IP，可将IP提取出来写入临时文件，并crontab一个定时任务（如每分钟检测一次），对比上次结果，若IP有变就发出邮件提醒。 而我们现在是直接在有外网IP的路由器上做检测，就没有这麻烦了，直接ifconfig就能知道WAN端口的各种IP配置，然后sed截取出需要的IPv4地址： 1ifconfig pppoe-wan | sed -En 's/.*addr:([0-9.]+).*/\\1/p' 知道了当前IP，还需要知道其是否有变。当然，也可以如前述那样起cron定时任务进行检测，也不会消耗什么资源。只是，在OpenWrt固件的路由器上，我们可以有一种更合理的方式。 hotplug脚本在OpenWrt系统中，提供了hotplug功能，后台相关daemon进程（procd）在监测到某些事件时会执行可自定义的一些shell脚本。利用这个特性，我们可以在/etc/hotplug.d/iface/目录下新建一个名为99-ipreport的脚本，内容如下： 12#!/bin/sh[ \"$ACTION\" = \"ifup\" -a \"$INTERFACE\" = \"wan\" ] && sh /root/update_ip.sh 文件名中的“99-”指定了脚本的执行顺序，越大越靠后。脚本的含义是，当wan接口发出ifup，即上线的事件消息时，就执行后面的/root/update_ip.sh，该脚本负责检测及通知更新后的IP（update_ip.sh脚本具体内容见文末附录）。本方法和前面的cron相比，可避免起定时任务，只在路由器重新拨号时，即IP真正可能发生变化时，执行检测脚本。 路由器发邮件关于路由器如何发邮件，网上已有很多教程，这里简单说明下。 一般OpenWrt固件，都已自带ssmtp邮件客户端，可方便的发邮件（如果固件不带，请尝试安装对应软件包）。我这里使用到的邮箱是163的，仅作参考。163邮箱需要先在设置中开启SMTP服务： 为保障邮箱安全，建议开启客户端授权密码： 邮箱设置完成后，在路由器的ssmtp设置文件/etc/ssmtp/ssmtp.conf加入以下配置： 123456789root=[your email]mailhub=smtp.163.comrewriteDomain=163.comhostname=openwrtFromLineOverride=YESAuthUser=[your username]AuthPass=[your password]UseTLS=YESUseSTARTTLS=YES 之后就能使用ssmtp命令了： 1echo -e \"To: [receiver email]\\nFrom: [your email]\\nSubject:[title]\\n\\n[content]\" | ssmtp [your email] 测试一下能否正常发邮件吧。 电脑端自动更新hosts因没有用到DDNS，我们可以把从邮件获取到的IP写入电脑本地的hosts文件中，以便访问该IP。 对于MacOS而言，系统集成的邮件客户端有个隐藏的强大功能，可以在收到新邮件时，进行规则匹配，通过脚本自动更新系统hosts，从而省掉了手动编辑的麻烦。这里的脚本就是苹果独有的AppleScript。 首先，确定/etc/hosts文件中有自定义的hostname： 然后，在邮件App设置里，添加新规则，如下进行设置： 可以看到，这里对邮件标题进行了规则匹配，只处理标题以特定字符串结尾的邮件。后面处理步骤应该很清晰了：拷贝到本地特定收件文件夹、设已读、加颜色旗标、运行AppleScript。这里的AppleScript就是我们自动更新hosts的地方了，内容可参考： 123456789101112131415161718192021delay 3tell application \"Mail\" set theMessages to messages of mailbox \"wgdzlhs_ubt\" --whose read status is false if theMessages is not {} then set aMessage to first item of theMessages set msgContent to content of aMessage --log \"mail of ip info: \" & msgContent & date sent of aMessage tell me to set wgdzlhs_ubt_ip to do shell script \"echo \" & quoted form of msgContent & \" | grep -Eo '[0-9]{1,3}(\\\\.[0-9]{1,3}){3}'\" --log \"wgdzlhs-ubt ip: \" & wgdzlhs_ubt_ip if length of wgdzlhs_ubt_ip > 0 then set pattern to \"s/^.+(wgdzlhs-ubt)/\" & wgdzlhs_ubt_ip & \" \\\\1/\" --log \"sed pattern: \" & pattern tell me to do shell script \"sed -Ei'_bak' \" & quoted form of pattern & \" /etc/hosts\" with administrator privileges end if --move theMessages to mailbox \"Trash\" repeat with oneMessage in theMessages delete oneMessage end repeat end if --log \"done.\"end tell 可以看到，AppleScript是一种近乎伪代码的风格，读起来应该比较易懂，这里就不做解释了。值得注意的是脚本中的sed命令，在编辑hosts时会对原文件进行备份，并需要提升权限（提示用户输入密码）。另外有个小技巧，在编写AppleScript时，如果需进行测试，输出log其实有点多余（故上面代码中的log命令都被注释掉了），在Script Editor应用中，点击运行后，有一栏能显示出各行命令的实际执行代码及其返回结果，如下图： AppleScript正常运行后，我们的hosts应该就更新好了，测试一下能否ping通家里的路由器： DDNS方法缘由当然，最方便的还是DDNS —— 有固定域名就不用麻烦去更新hosts，且适用所有电脑手机系统。最近因项目需要，在家里的台式机上部署了GitLab，希望整个团队都能方便访问到，这样就有多个终端、多个用户要访问我的家庭网络，前面的非DDNS方法已不适用了。下面介绍DDNS解决方案。 注册服务鉴于国内没有很好的免费DDNS，我将目光转向了国外。通过搜索，我发现了一家比较靠谱的，地址是：https://www.dynu.com。注册后，点击主页右上角齿轮： 进入后台控制中心，就能添加DDNS服务了，设置好自己想要的域名（三级域名免费），不再赘述。 路由器自动更新DDNS有了DDNS服务，同样需要在合适的时候，对记录在DDNS服务商那里的IP进行更新，故前面hotplug脚本里的update_ip.sh仍可沿用，只是里面运行的命令需要相应调整。 通过查阅该服务商提供的API文档，更新DDNS步骤如下： 生成API Key如下图，在这里生成自己账户的API Key，想要更安全一点也可以设定验证类型为OAuth2，做两步验证（多个临时token而已），这里只介绍API Key更新方式： 获取DDNS的用户ID运行下面curl，返回的JSON里就有id信息（一串数字），记录下来。这个命令只用运行一次，目的只是为获取DDNS服务的用户识别ID。 1curl https://api.dynu.com/v2/dns -H \"accept: application/json\" -H \"API-Key: [your API Key]\" 更新DDNS域名对应IP下面的命令在每次路由器发生拨号行为，并检测出WAN端口IP发生变化后，即需运行： 123curl https://api.dynu.com/v2/dns/[your DDNS id] -H \"Content-Type: application/json\" \\ -H \"API-Key: [your API Key]\" \\ -d \"{\\\"name\\\":\\\"[your domain name]\\\",\\\"ipv4Address\\\":\\\"[your new ip]\\\"}\" IP更新后，可用ping测试一番，看是否正常。具体所用的shell脚本请见文末附录。通过路由器hotplug功能，该脚本可如上面第3步里的那样，按需运行，不用起cron。至此，DDNS的问题已圆满解决。 附录最后，附上题图中的 update_ip.sh shell脚本，以供参考。该脚本同时采用了前面两种方式获取家网IP，以防DDNS服务失效： 1234567891011121314151617181920212223#!/bin/shsmail() { echo -e \"To: ${1}\\nFrom: [your email]\\nSubject:${2}\\n\\n${3}\" | /usr/sbin/ssmtp ${1}}ddns() { curl https://api.dynu.com/v2/dns/[your DDNS id] -H \"Content-Type: application/json\" \\ -H \"API-Key: [your API Key]\" \\ -d \"{\\\"name\\\":\\\"[your domain name]\\\",\\\"ipv4Address\\\":\\\"${1}\\\"}\" &> /dev/null}sleep 1cd /tmpif [ -f \"current_ip.log\" ]; then old_ip=$(cat current_ip.log)finew_ip=$(ifconfig pppoe-wan | sed -En 's/.*addr:([0-9.]+).*/\\1/p')echo ${new_ip} > current_ip.logif [ \"${new_ip}\" != \"${old_ip}\" ]; then smail [your email] \"$(date +'%Y%m%d %H:%M:%S') my ip updated --from wgdzlhs-ubt\" ${new_ip} ddns ${new_ip}fi 有任何疑问欢迎留言。","link":"/2019/10/01/apply-ddns-to-my-household-network/"},{"title":"为家庭服务器设置WOL","text":"在完成家庭组网后，剩下的工作就是各种优化了。其中应重点关注的，当属家庭网络设备运行的经济性，以及使用的方便性了。本文主要介绍WOL（Wake On LAN）在提高设备经济便捷性方面的应用。 问题的引出最近，在我重新启用家里的台式机，作为开发团队的GitLab服务器时，一个问题很快显现出来。 首先，之所以需要将家里的电脑当作服务器来用，主要有以下几点原因： 穷，买不起配置较好的VPS（GitLab对配置有要求） 家里路由器有公网IP，且已配好DDNS 台式机闲置已久，系统是Ubuntu 1604，可充当服务器 偶尔需要登录台式机，跑点测试，玩一下TensorFlow啥的（台式机有老独显，可加点速） 但，毕竟是过时硬件 + Linux，整个系统功耗有点高（八九十瓦至少），7*24运行的话，不仅会产生可观电费，机器也会快速积灰、折旧。同时经过观察，这台服务器使用频率非常低，一天半小时顶破天。 于是，要合理的利用，最好可以让服务器在不用的时候自动进入睡眠待机（挂起状态，此时绝大部分硬件不工作，功耗极低），而需要用的时候可以远程唤醒。 解决过程Ubuntu自动睡眠先从看似简单的下手。在Ubuntu系统中，需要设置在不活动一段时间后，自动进入睡眠状态，大家可能觉得这不是一个问题：在设置里的电源选项中设一下就好了嘛。 可是，经过实际操作检验，这样很可能不会成功，至少在我的这台Ubuntu 1604老系统上没用。即使我设置了在不活动10分钟后就挂起，但不管系统处于idle状态多久，它就是不睡。 经过分析，我发觉应该是系统中运行的某些服务阻止了电源选项发挥作用，如GitLab后台运行的一堆东西，数据库、nginx、Web服务器等，其中只要有一个让电脑不能主动进入睡眠状态，系统就不会在规定时间休息了。而一旦停掉GitLab所有服务，系统就可恢复正常。只是，停服务是不可能停的，这次停了某一个，下次再起别的什么服务后若又出问题，就又要重复排查。 强制睡眠如何解决自动睡眠问题？针对诸如此类系统方面的glitch，个人一贯追求简单直接的处理方法，不愿花太多精力去一一排查，追根究底。借用一位前同事的说法，我们毕竟是开发，不是运维，可能绕了一大圈，最后最有效的方法就是最简单直接的那个。 所以，既然不能利用系统自身的自动睡眠，那就手动强制睡眠吧： 1sudo systemctl suspend 通过sudo提权后，系统当然会乖乖去睡了。注意，可以睡眠不代表也能正常从睡眠中恢复，这时应测试一下唤醒情况。 PS：若你和我一样用的是N家的独显，在唤醒时如果发现系统当机了，内核panic，有可能是显卡驱动造成的，试着重装一下最新兼容驱动或许能解决。PPS：N卡驱动可能只在图形界面可以正常睡眠唤醒，如果将启动等级设为命令行界面，即text mode，不运行X server（少跑几十个进程），唤醒时依然会当机黑屏。这个至今没有妥善解决，后面若找到方法会分享出来（很有可能这是现有驱动本身的依赖特点，根本没有解决方法，除非发生小概率事件：未来新驱动支持text mode的睡眠唤醒）。 自动判断idle系统可以通过命令强制睡眠后，下一步就是如何在合适的时候运行这个命令了。 理想情况是，系统能自动判断前台或后台没有正在运行的用户程序，也没有远程用户在使用其提供的网络服务，且这种状态持续了可设定的一段时间，就认为系统正处于空闲，可以安全进入睡眠了。只是，前面已提到，设置中的电源选项在很多情况下不起作用。进一步的搜索表明，这里的电源选项仅能判断前台GUI界面中是否有用户活动，即鼠标或键盘事件，而不能探测后台中的活动，故其作用面非常有限。 有网友分享过自己的经验，也有一些开源脚本在特定情形可利用，但经过分析，判断系统idle状态其实并不复杂，可以用shell脚本加定时任务自行解决，不需要借助其他软件，下面贴出代码： 123456789101112131415161718192021222324#!/bin/bashuser_proc_num=$(ps -fU [your username] | grep -vE \"systemd|sd-pam|ps -fU|wc -l\" | wc -l)if [ ${user_proc_num} -gt 1 ]; then active=\"true\"else net_con_num=$(netstat -ant | grep -E \"[service socket 1]|[service socket 2]|...\" | grep -v \"LISTEN\" | wc -l) if [ ${net_con_num} -gt 0 ]; then active=\"true\" fifiout_inac=\"/tmp/inac_times.log\"if [ \"${active}\" = \"true\" ]; then echo 0 > ${out_inac}else inac_times=$(cat ${out_inac} 2>/dev/null || echo 0) if [ ${inac_times} -ge 10 ]; then echo 0 > ${out_inac} systemctl suspend else echo $(( ${inac_times} + 1 )) > ${out_inac} fifi 以上代码保存为auto_suspend.sh（注意修改其中的service socket为需要判断空闲状态的TCP端口），加可执行权限，在cron中起定时任务（root用户的crontab，因为systemctl suspend这句须提权）： 12$ sudo crontab -l*/1 * * * * /some_path/auto_suspend.sh 即每分钟运行一次，判断空闲状态。结合脚本中第18行里的10，可看到这里设置的是，若连续十分钟内，10次都未探测到系统有活动的进程或TCP端口，则认为系统处于空闲，可强制进入睡眠。 路由器唤醒Ubuntu手动唤醒在设置自动唤醒前，可先测试一下手动唤醒。测试之前，需打开Ubuntu网卡的WOL功能： 1$ sudo ethtool -s eno1 wol g 注：其中eno1改为需设置WOL的网卡名。然后看下是否配置成功： 1$ sudo ethtool eno1 输出有Wake-on: g，就说明已成功设置WOL。在Ubuntu上systemctl suspend后，SSH登入路由器，运行以下命令： 1$ etherwake -b -i [LAN interface name] [ubuntu MAC address] 测试是否可以成功唤醒Ubuntu。注：除了这种etherwake命令方式，还有其他各种WOL工具可以使用。若从外网唤醒，需要在路由器上配置好端口转发，但此种转发方式的弊端是，只能在Ubuntu直接连在路由器某LAN网口上，且配置好静态ARP绑定的条件下才行，否则会因ARP老化而无法成功转发magic唤醒包（例如像这里的网络拓扑，路由器与Ubuntu Desktop PC之间有其他网桥设备）。所以，最好直接从路由器发出广播型的magic包，不管内网的二层拓扑怎样，Ubuntu都能正常收到而被唤醒。故上面etherwake命令里有-b参数，即发出broadcast型magic包。 自动唤醒手动唤醒测试通过后，下一步就是将其自动化。如何在需要连接Ubuntu时，自动将其唤醒？简单的端口转发当然无法做到这个，我们需要的是一种路由器可以察觉到的连接信号。经过搜索，我找到了一种很好的解决流程： 某客户端在外网发出连接Ubuntu的TCP第一次握手（SYN=1 ACK=0）； 路由器iptables转发时，识别出该数据包，发出特定信号； 路由器上某进程接收到该信号，运行etherwake命令，发出二层广播magic包唤醒Ubuntu。 识别TCP第一次握手利用iptables监听跳转，可识别特定TCP第一次握手包，发出相应信号。这里的信号是写入特殊字符串开头的系统日志，其他进程可以通过实时读取日志来识别这个信号。之所以采取这种迂回方式，主要原因是iptables无法直接启动其他命令或脚本。 根据OpenWrt官网提供的iptables设置样例，我们的监听跳转命令如下： 12345678# create a new chain for logging forwarded packetsiptables -N forwarding_log_chain# append to openwrt forwarding_rule chain (which generally has nothing in it)iptables -A forwarding_rule -j forwarding_log_chain# add log rules all HTTP/S SYN (can use --syn instead of --tcp-flags) and FIN-ACK eventsiptables -A forwarding_log_chain -p tcp -d [LAN ip of the server] --tcp-flags ALL SYN -j LOG --log-prefix \"MY_PC_SYN:\" 这些命令可以写入OpenWrt的防火墙自定义规则中，在防火墙每次启动时自动运行。 发出广播唤醒包在路由器上使用nohup另起一个后台进程，实时读取系统日志，发现有连接Ubuntu的TCP第一次握手信号，就发magic唤醒包。当然，通过优化发包逻辑，可以适当限制一下发包频率，避免给LAN传太多二层广播（虽说这里的广播包很小，占用带宽极小，但有优化总是好的）。 1nohup logread -f | awk '/MY_PC_SYN/ {system(\"/root/auto_wol.sh\")}' & 这个nohup任务可以写在/etc/rc.local里，随系统启动。其中的/root/auto_wol.sh脚本内容如下： 1234567891011121314151617181920212223242526#!/bin/shoutfile=\"/tmp/autowake.tmp\"last_time=$(date +%s -r ${outfile} 2>/dev/null || echo 0)interval=$(( $(date +%s) - ${last_time} ))epoch=$(cat ${outfile} 2>/dev/null || echo 0)if [ ${epoch} -eq 0 ]; then if [ ${interval} -le 6 ]; then etherwake -b -i [LAN interface name] [ubuntu MAC address] echo 2 > ${outfile} else echo 1 > ${outfile} fielse if [ ${interval} -le 6 ]; then if [ ${epoch} -eq 1 ]; then etherwake -b -i [LAN interface name] [ubuntu MAC address] echo 2 > ${outfile} fi elif [ ${epoch} -eq 2 ]; then echo 1 > ${outfile} else echo 0 > ${outfile} fifi 可以看到，第16行设置了6秒内，最多只会发出一个广播唤醒包。 同时，我们的脚本还可以防IP端口扫描器的扫描骚扰，避免无谓的唤醒（通过检查系统日志，发现几个来自荷兰的IP隔几个小时就对我的路由器各端口进行扫描，疑似想通过漏洞侵入系统）。 这里具体的实现原理很简单，IP扫描器为了提高效率，每个IP:SOCKET套接字一般只会发出一个TCP握手包，没响应就扫下一个，而正常的TCP访问更执着，第一个握手包没响应，一两秒内会发出另一个。利用两者区别，可以故意设计为只响应连续的握手包，而对孤立的包置之不理。所以，脚本的状态就有了0、1、2这三个，三者间的转化关系如下： 几点思考 这样的TCP连接惰性处理，在能抵抗一次IP套接字扫描的同时，也多少增加了服务器的响应时延。经过外网访问测试，服务器从睡眠中自动唤醒，没有惰性处理和有惰性处理，相隔1-2s，在总时延10s左右的情况下，可忽略不计。 引入WOL后，所有的网络服务大多情况下均会附加一个较长的10s初始时延，对用户体验有点影响，但在节省大量资源的利益面前，这点影响同样可忽略不计了。 至此，WOL问题已得到解决。","link":"/2019/10/03/apply-wol-to-my-household-server/"},{"title":"我的家庭网络架设日志","text":"家里的自建网络在近三年经历了多次升级改造，目前已稳定下来，并正常运行一年有余。多次改造过程中，搜索、学习了不少网络底层知识，现在大致记录一下。 硬件介绍先看看目前我家里的网络拓扑图吧： 图中的光猫是自行更换的（电商平台有售，8245C2改H版的也行，网上有更换教程），主要看中了其转发性能和LAN四口千兆，运行也远比电信送的渣渣稳定可靠，三年时间中没有出过任何故障，而周围邻居用的总在掉线。电信在近期对其网络设备进行了升级，接收到的光信号又升了几个dB（-20dB -> -14dB），就更稳了。现在只希望能尽快提供IPV6吧。 路由器+无线AP用的是原思科子品牌Linksys的 WRT1900ACS。WRT系列在路由器固件开源史上可谓无出其右，对OpenWrt等开源固件的支持非常好，这是我最看重的地方。目前这个路由器用的固件是我自行编译的，虽说各种社区里的网友共享固件也能满足需求，但我有新版强迫症情结，也不喜欢路由器里有用不到的功能，所以就自己定制了。这里强烈推荐一下某大神的OpenWRT编译仓库，该repo集成了多种路由器的编译配置，喜欢的学习一下怎么弄吧。 IPTV机顶盒是电信送的，看直播方便些。可能你已看出来一个细节：IPTV没有接到光猫上，而是通过了路由器，具体怎么实现的下面在VLAN小节里会介绍。 无线WIFI方面，目前家里其实是主用5G的，速度快干扰少，小户型的信号衰减也没有那么厉害，完全堪用。2.4G给老设备和智能家居设备使用。 NAS是用一台2009年的老笔记本来充当的，10年了舍不得丢，换过SSD，只用AC电源，希望还能再撑10年。系统仍用Win 7，7*24运行中，异常稳定。没刷NAS专用系统，感觉Win完全够用，也很方便，要啥有啥（也许是因为太懒，换系统毕竟有成本啊）。 家庭VLAN设置熟悉网络架构的同学应该清楚，VLAN是二层（数据链路层）协议，对传统LAN进行了进一步的分割，可以在同一物理网络上架设多个虚拟的LAN。光网改造后，各电信服务商在家庭接入网这块，也全面应用了VLAN技术，主要是对远程光猫控制、互联网接入、IPTV、IP电话等业务进行了VLAN隔离，保证QOS。较新的光猫设备都支持自行设置VLAN（一些型号可能需要破解超密，本文不介绍这方面的知识，请善用搜索），而一般的家庭路由器对VLAN的支持可能并不充分，需要刷固件。细心的你可能也看到上面拓扑图中的一个细节，光猫和路由器之间的有线连接是双向箭头的，和其他的不一样。其实这里就是用到了VLAN，具体如下。 从需求说起我家当时装修时，没考虑到家庭路由的位置问题，犯了个设计上的错误：所有房间的网口都接到玄关的弱电箱里了（这种情况应该是挺普遍的吧）。后来组网时发现，如果用光猫拨号，NAS、台式机、路由器平行接入光猫，很可能造成光猫转发压力大，过热不稳定（更换光猫前），也不便于台式机通过路由器科学上网；而如果光猫桥接，在路由器PPPoE拨号（可避免多一层网络，多一层转发），NAS和台式机又要有线接入，这样使用传统方法组网，路由就必须放在弱电箱那里（不走明线的话），离WIFI使用者远，信号衰减厉害。所以，路由器最好能放在位于家庭中心的客厅电视柜上，利用那里唯一的网口连接光猫，而NAS和台式机通过光猫连接路由器，如拓扑图中那样。 现有方案通过搜索，网友分享的方案主要有以下两个（搜索单臂路由）： 方案1：在弱电箱中加入一个带VLAN功能的交换机，光猫、路由器、NAS、台式机都接入这个交换机，通过VLAN分割流量。 方案2: 利用光猫本身的VLAN交换功能，对WAN和LAN流量进行分割。 本着穷逼一贯的极简设计、物尽其用原则，当然选方案2啦。 光猫VLAN设置光猫WLAN配置 首先是内网VLAN设置，这里分配了VLAN-1给光猫、路由器、NAS和台式机，先绑定了NAS和台式机接入的LAN1、LAN3端口；LAN2为路由器接入端口，需要绑定多个VLAN（即trunk口），故不勾选；LAN4无设备接入，也不勾选。 WAN外网桥接设置，分配的VLAN ID为电信局方下发的，一定要配置对。换光猫前要从老猫那里记录下来（另外要记录的还有其他业务的VLAN ID和设备LOID，即逻辑ID）。这里没有绑定任何端口，会在后面进行trunk绑定。 IPTV设置，同样，这里的VLAN ID为电信指定好的，不能更改为其他的ID。IPTV会用到组播，设置一下所在地区的组播VLAN。 光猫LAN设置 光猫LAN端口工作模式，这里只需要勾选LAN2端口，LAN1和LAN3已做过绑定，所以默认就已勾选。 光猫LAN IP设置，地址设为路由器的内网IP段中的某个未使用的静态地址，掩码保持一致，这样可以方便路由器内网设备登录到处于桥接模式的光猫。 光猫DHCP设置，因光猫只作桥接，无路由转发职责，关闭所有DHCP功能即可。 VLAN trunk端口设置 重点来了，在光猫路由设置栏这里，需对LAN2端口进行多重VLAN绑定，上图中同时绑定了三组，分别为： 路由器侧WAN／光猫侧WAN 路由器侧IPTV／光猫侧IPTV 路由器侧LAN／光猫侧LAN 至此光猫VLAN已设置完成。 路由器VLAN设置路由器交换机设置 此步同样关键。如图，在路由器的交换机设置栏中，对VLAN ID 1-3进行如下分配： 内网1绑定网卡eth0，以及除接有IPTV机顶盒的LAN3外的所有端口（包括WAN端口）； 外网2绑定网卡eth1，以及WAN端口； IPTV网3绑定接有IPTV机顶盒的LAN3，及WAN端口。 其中，可以看到，因WAN端口为trunk口，与连接的光猫处于多个VLAN中，故必须设为打VLAN ID标签的模式tagged，以区分不同流量，而其他端口连接的设备已离开VLAN，故设为untagged。另外有个小细节：IPTV所在的VLAN 3 未分配到网卡上，因为其只需二层转发，不用动IP层，不划到LAN中，防火墙能少处理一点流量吧。 路由器接口设置 WAN接口这里，在物理设置中须绑定eth1.2接口（即交换机中的eth1网卡和VLAN 2），然后在基本设置中设定好PPPoE拨号即可，此时可测试一下能否拨号成功。 如图，LAN接口同样须设置接口绑定，只是绑定的是eth0.1，还有两个无线WIFI，可开启组播（主要为了IPTV，不开应该也行，毕竟IPTV不在LAN中）。 LAN基本设置，注意IP地址和掩码与上面光猫LAN侧的对应，保持在同一内网网段即可。 LAN接口的DHCP服务器设置中，开始IP可设置到高地址段，低地址段预留给手动配置静态IP的设备，如光猫的LAN地址、NAS和台式机。另外提一句，路由器的DHCP协议包一般情况下无法跨越光猫，即使设置好了VLAN和网段（可能需要光猫支持LAN侧的DHCP中继才行吧），故NAS和台式机是手动配置的静态IP，同时也便于内网访问及做静态ARP绑定。 问题与思考 单臂路由是否影响网速？ 对于这个问题，我上网找过相关资料，发现在家用环境下，网速基本无影响。这里要理解的是1000baseT 全双工这个概念，全双工与单工的区别就在于，其可支持网络两端同时以标称速度进行收发包（上下行带宽均可达到1000M），而单工要达到标称速度只能一端发，另一端收，不能两端同时收发，否则速度就会减半。所以即使用到了单臂路由，非极端情况（典型家用情境），内网带宽扔可保持全千兆，与非单臂路由情况基本无差，完全够用。当然，这里的分析都是基于内网各条线路、接口均能达到千兆双工的前提，若达不到，建议有条件就升级线路，用好点的线（超五类即可）+ 质量过关的水晶头和网口面板，自己动手把关，避免在物理层出现降速瓶颈。 至此，所有设置已完成，可以欢快的上网了。接下来，关于家庭网络搭建，会继续介绍关于DDNS和WOL的内容，干货多多，敬请期待。","link":"/2019/09/29/how-do-i-construct-my-household-network/"}],"tags":[{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"Android","slug":"Android","link":"/tags/Android/"},{"name":"家庭组网","slug":"家庭组网","link":"/tags/%E5%AE%B6%E5%BA%AD%E7%BB%84%E7%BD%91/"},{"name":"DDNS","slug":"DDNS","link":"/tags/DDNS/"},{"name":"shell","slug":"shell","link":"/tags/shell/"},{"name":"AppleScript","slug":"AppleScript","link":"/tags/AppleScript/"},{"name":"WOL","slug":"WOL","link":"/tags/WOL/"},{"name":"iptables","slug":"iptables","link":"/tags/iptables/"},{"name":"TCP","slug":"TCP","link":"/tags/TCP/"},{"name":"VLAN","slug":"VLAN","link":"/tags/VLAN/"},{"name":"光猫","slug":"光猫","link":"/tags/%E5%85%89%E7%8C%AB/"},{"name":"路由器","slug":"路由器","link":"/tags/%E8%B7%AF%E7%94%B1%E5%99%A8/"}],"categories":[{"name":"安卓开发","slug":"安卓开发","link":"/categories/%E5%AE%89%E5%8D%93%E5%BC%80%E5%8F%91/"},{"name":"折腾","slug":"折腾","link":"/categories/%E6%8A%98%E8%85%BE/"}]}